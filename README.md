Protobuf RPC over HTTP 1 - PHP server
=====================================

[![build](https://github.com/timostamm/protoc-h1-php-server/workflows/CI/badge.svg)](https://github.com/timostamm/protoc-h1-php-server/actions?query=workflow:"CI")
![Packagist PHP Version](https://img.shields.io/packagist/dependency-v/timostamm/protoc-h1-php-server/php)
[![GitHub tag](https://img.shields.io/github/tag/timostamm/protoc-h1-php-server?include_prereleases=&sort=semver&color=blue)](https://github.com/timostamm/protoc-h1-php-server/releases/)
[![License](https://img.shields.io/badge/License-MIT-blue)](#license)

PHP utilities to implement protobuf services on a simple HTTP server.

Supports all unary RPC calls over HTTP 1. 

For auto-generated clients, see https://github.com/timostamm/protoc-h1-plugins


Lets say you have this service defined in a proto file:

```
option php_generic_services = true;

service SearchService {

    rpc Search (SearchRequest) returns (SearchResponse);

}
```

From this file, protoc generates a generic service interface 
`SearchServiceInterface.php`. You just implement this interface with your 
business logic. 

Then you can let `HttpHandler` take care of request and response:  


```php
/**
 * @Route( methods={"PUT"}, path="{serviceName}/{methodName}" )
 */
public function execute(RequestInterface $request, string $serviceName, string $methodName): Response
{

    $resolver = new ServiceResolver();
    $resolver->registerInstance(
        SearchServiceInterface::class, // the interface generated by protoc 
        new SearchService() // your implementation of the interface
    );

    $handler = new HttpHandler($resolver);

    // turn on details in error messages
    $handler->setDebug(true); 

    // will log exception details, regardless of debug mode
    $handler->setLogger($myPsrLogger); 

    return $handler->handle($serviceName, $methodName, $request);
}
```

